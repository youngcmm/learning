# 算法笔记

## 回溯法

力扣第70题

```c++
void backtrast()//参数
{
	if()//终止条件
	{
	//存放结果
    return ;
	}
    for()//处理节点
    {
        //处理节点
		backtrast();//递归
        //回溯，撤销结果
    }
}
```

组合问题是回溯法解决的经典问题。

## 素数

​	大于1的只能被1或本身整除的数

1. **素数快速筛**

```c++
vector<int> prime;
vector<bool>isnotprime(n,false);//是素数设置为false，初始认为全部是素数
for(int i = 2;i <= n ;i++)
{
	if(isnotprime[i]) continue;
    prime.insert(i);
    for(int j = i; j <= n;j=j+i)//i的整倍数的数都不是素数
        isprime[j] = true;
}

```

## 牛吃草问题

​	消耗的资源等于新生的资源时为最优解，即求解最大承受的牛的数量。

## 判断直线的问题

​	判断直线将斜率比转化为乘法运算，可避免精度不够的问题。

```mathematica
(x1-x2)/(y1-y2)=(x1-x3)/(y1-y3)
(x1-x2)*(y1-y3)=(x1-x3)*(y1-y2)
```

## 切比雪夫距离

​	在一二维坐标系中，一个点` （X0,Y0)`到另一个点`(x1,y1)`移动的最少次数等于

`max(abs(x0-x1),abs(y0-y1))` 。

证明:

```mathematica
令dx = |x0-x1|, dy = |y0-y1|
若dx>dy,则
先移动dx，在移动dy-dx。总移动次数为dx+(dy-dx)=dx
若dx<dy，同理得，总移动次数dy。
若dx=dy，得dy。
```



## 溢出

1. 关于`pow(10,n)`有可能对于double的范围会有溢出。
1. for循环的起初和结束，特别是涉及i-1和i+1时。

## 字符串中的单词

```c++
    string s1;
    getline(cin,s1);
    vector<string> ans;
    string  temp="";
    for(int i = 0 ; i < s1.size();i++)
    {
        if(isalpha(s1[i]))
        {
            temp+=s1[i];

        }
        if(!isalpha(s1[i])||i==s1.size()-1)
        {
            if(temp!="")
            {
                ans.push_back(temp);
                temp = "";
            }
        }
    }
```

## 进制转化

**十进制转其他进制**

```c++
//n是十进制,转成p进制
int ans = 0;
while(n)
{
    ans+=n%p;
    n = n/p;
}
```

**其它进制转化为十进制**

```c++
//n为p进制,这里的n只为0到9不含字母，若含有字母考虑字符串处理，原理与此类似。
int ans = 0;
int index = 1;
while(n)
{
    ans = ans + (n%10)*index;
    n = n/10;
    index = index*p;
    
}
```

## 字符串与整型的互换

​	整型可以直接变成字符串`string s = to_string(temp)`

​	字符串可以直接变成整型（如果是数字字符串，否则会报错）`stoi(str)`

​	以上俩者均在`string`头文件下

## 图论

### dijkstra

​	求解单源最短路径，也可以求解多源（通过将多个值作为单源传入，反复调用即可）。

**注意： dijkstra算法不能用于带负权值的图**

伪代码：

```c++
Dijkstra(G,d[],vis[],s)//G是图，d[]为到单源的最短路径数组，vis[]记录访问，初始设为INT_MAX,s为源。
{
    d[s] = 0;
    for(int i = 0 ; i < n ; i++)
    {
        u = -1//记录目前到源s最短的距离
       if (i未被访问&&d[i]!=INT_MAX)
        {
			u //查找距离最短的到源s的顶点i把i标记为u；
        }
        if(u==-1) retrun ; //若未找到u则返回。
         vis[u]//标记u已被访问。
        for(int v = 0;v<n;v++) //遍历与u相连的v
        {
        如果u与v相连并且d[v]>d[u]+d[uv]并且v未被访问（很重要），则优化v；//只会在单源的循环处标记访问
        }
    }
}
```

#### 详细代码

```c++
//邻接表版本
vector<vector<int > > G(10000,vector<int>(10000,INT_MAX));
vector<int> d(10000,INT_MAX);
vector<bool> vis(10000,false);
int n;//n个顶点
void Dijkstra(int s)
{
    d[s] = 0;
    for(int i = 0 ; i < n ;i++)
    {
        int u = -1;
        int mindis = INT_MAX;
        for(int j = 0 ; j<n ;j++)
        {
            if(d[j]!=INT_MAX&&vis[j]==false)
            {
                if(d[j]<mindis)
                {
                    u = j;
                    mindis = d[j];
                }
            }
        }
        if(u==-1) return;
        vis[u] = true;
    //查找与v相连的u并开始优化
        for(int v = 0 ; v < n ;v++)
        {
            if(G[u][v]!=INT_MAX&&d[v]>d[u]+G[u][v]&&vis[v]==false)
                d[v] = d[u]+G[u][v];
        }
    }
}
int main()
{

    int m,s;
    scanf("%d %d %d",&n,&m,&s);
    int u,v,w;
    for(int i = 0 ; i < m;i++)
    {
        scanf("%d %d %d",&u,&v,&w);
        G[u][v] = w;//有向图，若是无向图则同时标记G[v][u] = w;
    }
    Dijkstra(s);
    for(int i = 0 ;i < n ; i++)
    {
        cout<<d[i]<<" ";
    }
    return 0;
}
//测试用例
/*
6 8 0  //6个顶点8个边源点是0
0 1 1  //以下（包括改行)输入u v w
0 3 4
0 4 4
1 3 2
2 5 1
3 2 2
3 4 3
4 5 3
*/
```

#### 例题A1003救援小组

​	N个城市，M条无向边将每个城市相连，边有的权值（两城市的距离），且点也有权值（每个城市的救援队的数量）。求从单源点（某一个城市）到目的城市的最小路径，若有多条相同的路径则选择救援队的和最多的路径，并输出路径的数量。



## 动态规划(DP)

### 数塔问题

```
5
8 3 
12 7 16
4 10 11 6
9 5 3 9 4
```

计算从塔顶到塔底的路径，使得该路径求和的值最大。路径只能选择下一层的相邻两个数。

```mathematica
//按自低向上的方法求解
//转移方程
dp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+nums[i][j]
```

详细代码：

```c++
#include <bits/stdc++.h>
using namespace std;
const int maxv = 1000;
int dp[maxv][maxv];
int nums[maxv][maxv];
int main(){
    int n;
    scanf("%d",&n);
    for(int i = 1 ; i <= n ; i++)//注意统一从一开始计数方便计算
    {
        for(int j = 1 ; j <= i;j++)
        {
            int temp;
            scanf("%d",&temp);
            nums[i][j] = temp;
        }
    }
    for(int j = 1 ; j <= n;j++)
    {
        dp[n][j] = nums[n][j];
    }
    for(int i = n-1;i>=0;i--)
    {
        for(int j = 1 ; j <= i;j++)
        {
            dp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+nums[i][j];
        }
    }
    cout<<dp[1][1]；
	return 0;
}
/*输入
5
5
8 3
12 7 16
4 10 11 6
9 5 3 9 4
*/
//输出结果 44
```



# 更新时间2022.3.25



